---
title: "FinalProject"
author: "Ben Hertzberg"
date: "2022-11-28"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r, message=FALSE}
library(tidyverse)
library(tidymodels)
library(corrplot)
library(rpart.plot)
library(vip)
library(janitor)
library(discrim)

```


```{r, eval = FALSE}
used_cars <- read.csv('./UsedCars/us-dealers-used.csv')
used_cars <- clean_names(used_cars)
```
Import data set. Must subset before doing anything with the data, including fitering ot missing values, because it is too big. Receieved error: 'Error: cannot allocate vector of size 569.1 Mb'
```{r, eval = FALSE}
set.seed(619)
uc_subset<- sample_n(used_cars, size = 50000)
uc_subset[uc_subset ==""]<- NA
uc_subset2 <- na.omit(uc_subset)
write_rds(uc_subset2, file = 'data/used_cars_cleaned.rds')
```

```{r}
uc_clean <- read_rds(file = 'data/used_cars_cleaned.rds')
```

```{r}
uc_clean <- subset(uc_clean, select = -c(id, vin, stock_no, seller_name, street, city, zip)) %>%
    mutate(model = str_replace(model, " ", "_"))
```

Right off the bat I remove variables I am not interested in


```{r}
uc_clean <- subset(uc_clean, select = -c(trim))
uc_clean <- subset(uc_clean, select = -c(state))

```

```{r}
uc_clean$make <- as.factor(uc_clean$make)
uc_clean$model <- as.factor(uc_clean$model)
uc_clean$body_type <- as.factor(uc_clean$body_type)
uc_clean$vehicle_type <- as.factor(uc_clean$vehicle_type)
uc_clean$drivetrain <- as.factor(uc_clean$drivetrain)
uc_clean$transmission <- as.factor(uc_clean$transmission)
uc_clean$fuel_type <- as.factor(uc_clean$fuel_type)
uc_clean$engine_block <- as.factor(uc_clean$engine_block)
uc_clean$price <- as.numeric(uc_clean$price)
uc_clean$miles <- as.numeric(uc_clean$miles)
uc_clean$year <- as.numeric(uc_clean$year)

```




### Graphs

```{r}
model_plot<-ggplot(uc_clean, aes(y = model)) + 
  geom_bar()
model_plot
```


```{r}
model_counts <- table(uc_clean$model)

common_models <- subset(uc_clean, model %in% names(model_counts[model_counts > 300]))
common_models<-droplevels(common_models)

```

```{r}
type_1_plot<-ggplot(common_models, aes(y = model)) + 
  geom_bar()
type_1_plot
```


### Splitting
```{r}
set.seed(619)
uc_split <- initial_split(common_models, prop = 0.80, strata = model, pool = 0.01)
uc_train <- training(uc_split)
uc_test <- testing(uc_split)
```



```{r}
uc_train %>% 
  select(is.numeric) %>% 
  cor(use = "complete.obs") %>% 
  corrplot(type = "lower", diag = FALSE)
```

The correlation plot shows strong relationships between many of the continuous variables in this data set. Price has a strong negative correlation with miles, which makes sense - no car lasts forever, so people tend to prefer cars that have been driven less. There is a strong positive correlation between price and year, which means newer cars have a higher price. There is also a stong positive correlation between price and engine size; a car with a bigger engine will cost more. Car companies often tout the horsepower of a car, so assuming a larger engine means a more powerful vehicle, this relationship checks out too.

There is a very strong negative correlation between year and miles. This means newer cars (with a larger value for year) tend to have fewer miles driven on them. Sounds right to me. 

There is a slight positive correlation between engine size and miles, and a slight negative correlation between engine size and year. These relationships are harder to explain. The first relationship is a mystery to me. As far as the second one, my best guess would be that cars have gotten smaller and more fuel efficient in recent years, which might mean engine sizes have decreased.


### K-Fold

```{r}
uc_folds <- vfold_cv(uc_train, v = 5)
uc_folds
```

### First Model 

```{r}
uc_rec <- recipe(model ~ price + miles + year +drivetrain+engine_size+transmission, data = uc_train) %>% 
  step_dummy(all_nominal_predictors()) %>% 
  step_normalize(all_predictors())
```

```{r}
lda_mod <- discrim_linear() %>% 
  set_engine("MASS") %>% 
  set_mode("classification")

lda_wkflow <- workflow() %>% 
  add_model(lda_mod) %>% 
  add_recipe(uc_rec)

lda_fit <- fit(lda_wkflow, uc_train)
```


```{r}
lda_acc <- augment(lda_fit, new_data = uc_train) %>% 
  accuracy(truth = model, estimate = .pred_class)
lda_acc
```
```{r}
predicted_data <- predict(lda_fit, new_data = uc_train, type = 'prob')

```


```{r}
augment(lda_fit, new_data = uc_train) %>% 
  roc_auc(model, .pred_3_Series:.pred_X3)

augment(lda_fit, new_data = uc_train) %>%
  roc_curve(model, .pred_3_Series:.pred_X3) %>%
  autoplot()

augment(lda_fit, new_data = uc_train) %>%
  conf_mat(truth = model, estimate = .pred_class) %>% 
  autoplot(type = 'heatmap') 
```


```{r}
lda_fit_k <- fit_resamples(lda_wkflow, uc_folds)

```

```{r}
collect_metrics(lda_fit_k)
best_lda_mod <- select_best(lda_fit_k, metric = 'roc_auc')

```

```{r}
uc_lda_final <- finalize_workflow(lda_wkflow, best_lda_mod)
uc_final_lda_fit <- fit(uc_lda_final, data = uc_train)
```

```{r}
augment(uc_final_lda_fit, new_data = uc_train) %>% 
  roc_auc(model, .pred_3_Series:.pred_X3)

augment(uc_final_lda_fit, new_data = uc_train) %>%
  roc_curve(model, .pred_3_Series:.pred_X3) %>%
  autoplot()

augment(uc_final_lda_fit, new_data = uc_train) %>%
  conf_mat(truth = model, estimate = .pred_class) %>% 
  autoplot(type = 'heatmap') 
```

### Second Model

```{r}
net_mod <- 
  multinom_reg(penalty = tune(), mixture = tune()) %>% 
  set_mode('classification') %>% 
  set_engine('glmnet')

net_wkflw <- workflow() %>% 
  add_recipe(uc_rec) %>% 
  add_model(net_mod)
```


```{r}
net_grid <- grid_regular(penalty(range = c(-5, 5)), mixture(range = c(0,1)), levels = 3)
net_grid

```

```{r}
elastic_tune_res <-tune_grid(
  net_wkflw,
  resamples = uc_folds,
  grid = net_grid
)


write_rds(elastic_tune_res, file = 'SavedModels/uc_elastic_res.rds')

```

```{r}
uc_elastic_res <- read_rds(file = 'SavedModels/uc_elastic_res.rds')

```

```{r}
collect_metrics(uc_elastic_res) %>% arrange(desc(mean))

```

```{r}
best_elastic_mod <- select_best(uc_elastic_res, metric = 'roc_auc')
uc_elastic_final <- finalize_workflow(net_wkflw, best_elastic_mod)
uc_elastic_final_fit <- fit(uc_elastic_final, data = uc_train)
```

```{r}
augment(pok_final_fit, new_data = pok_test) %>% 
  roc_auc(type_1, .pred_Bug:.pred_Water)

augment(pok_final_fit, new_data = pok_test) %>%
  roc_curve(type_1, .pred_Bug:.pred_Water) %>%
  autoplot()

augment(pok_final_fit, new_data = pok_test) %>%
  conf_mat(truth = type_1, estimate = .pred_class) %>% 
  autoplot(type = 'heatmap') 
```